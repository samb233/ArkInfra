# domain

基建系统充血模型的建模过程。

## 原则

对于纯CRUD的需求，使用贫血模型能快速构建应用；而对于稍微复杂的、功能多的，或是对拓展性要求高的需求，推荐使用充血模型进行建模。

## 面向对象分析

分析功能点，提取功能中数据相关的操作。以下为分析过程仅面向分析者自己，读者可能会看得比较迷糊。但思路就是通过分析功能的具体实现过程，划出其中的数据，确定实体和值对象，从而抽象出数据结构。

### 为新玩家新建基建数据

1. 提取出请求中的**用户ID**

2. 创建该用户的基建系统

   具体为：一个1级制造站、一个1级贸易站、一个1级发电站，其余房间为不可用状态（可标记为0级）

得到信息：每个用户有唯一的基建系统，***基建系统具有唯一的ID即用户ID***。基建系统***由房间组成***，***每个房间各不相同，具有等级、类型等属性***



### 玩家进入首页时，在首页显示基建系统产出了多少物品，有多少工厂停工了，只显示数字

（以下略过提取用户信息、根据ID还原基建系统对象等过程）

1. **每个房间**根据当前时间与**上次操作时间**的差，计算房间内产出多少**物品**、**人员**消耗了多少**疲劳值**
2. 对每个房间的数据进行汇总，得出**产出数字**、**停工数字**

具体的计算方法：

首先设时间的差为`t`，房间具有的**生产分数**为`score`，假设分数达到100时就生产出一个物品，**每小时增加的生产分数**为`sPerHour`，房间具有的**库存**为`storage`，当前房间**已占用的库存**为`usedStorage`，当前工作人员中*最小的疲劳值*为`minFtg`。

```
// 假设时间精度为1小时，即每小时更新一次
while t > 0 {
    // 如果三人疲劳，则break
    // 检查是否库存已满，已满则break
    
    storageRemain = storage - usedStorage
    st = storageRemain * 100 / sPerHour
    duration := min(st, minFtg, t)
    
    t -= duration
    totalScore = sPerHour * duration
    score = total % 100
    usedStorage += total / 100
    
    // 检查是否有人疲劳，有则刷新物品每小时生产分数、库存等
}
```

1. 

得到信息：

**基建**：基建需要对房间的数据*进行汇总*，有***产出数字、停工数字***属性

**房间**：基建系统由房间组成，***每个房间是不同的***，每个房间具有***上次操作时间、产出的物品、当前的生产分数、每小时增加的生产分数、库存、已占用的库存、进驻的工作人员***等属性，***房间需要修改自己的属性***

**物品**：由***物品ID***标识，每个物品的***初始生产分数***、***库存可以容纳数量***是不同的，但每个**物品的属性固定**，**不同房间可以生产相同的物品**，故物品是一个值对象

**工人**：每个房间最多可以进驻三名工人，工人其实就是游戏中的角色，由角色ID标识。工人拥有***ID***、***每小时消耗疲劳***、***剩余疲劳***、***技能***等属性。由于在基建中，**工人在所有房间中都是唯一的，不同房间不能有同一个工人，更换房间时会继承疲劳值等属性**，所以工人是一个实体。

**工人的技能**：工人的技能既可以作用于自身，降低自身的疲劳值消耗；也可以作用于房间，增加房间的库存、增加物品的生产分数等；甚至可以有全局效果作用于整个基建，提升所有某种类型工厂的生产分数等。在后文触及到具体需求时进行分析。

在这里我们已经可以勾勒出大致的数据结构

```go
// 大致的数据结构

// 基建
type Infra struct {
	ID    int
	Rooms []*Room
     Producted   int
	StopProduce int
}

// 房间
type Room struct {
	ID         int
	Type       int
	Level      int
	LastOpTime time.Time // 减少计算，可以上沉到Infra
    
     Storage     int
	StorageUsed int

	Item             *Item
	ItemScore        int
	ItemScorePerHour int

	WorkerID         []int
}

// 物品
type Item struct {
	ID      int
	Storage int
	Score   int
}

// 工人
type Worker struct {
	ID         int
     RoomID     int
	FtgRemain  int
	FtgPerHour int
	Skill      *Skill
}

```

对当前数据结构进行简单的优化，

人物技能Skill的设计在更换人物时设计

### 基建详情

同上，只是返回值变成了整个基建所有的细节，具体细节已在上一节阐述。

### 获取产出物品/批量获取产出物品

1. 获取房间ID
3. 将该房间的`usedStorage`清零
3. 调用物品服务，传递物品ID、数量，增加玩家的物品

### 升级建筑

1. 获取房间ID
2. 调整房间等级，调整可进驻的**人员数量**、可生产的**物品列表**
3. 游戏中大概是出于“装修时必须搬出去”的考虑，会将房间所有属性清空，我觉得没有必要

得到信息：房间具有属性***可进驻的人员数量、可生产的物品列表***，但这部分的属性***放在房间中不合适***，每个房间中这些信息都是一样的，甚至整个服务中数据都是一样的。可以新建两个对象用于处理这些数据的初始化、验证等。

#### 修改建筑产出物品

1. 获取房间ID
2. 判断是否可以生产
3. 

#### 修改房间工作人员

1. 从请求中解析出房间ID、更换的工作人员ID
2. 更换

数据结构设计基本决定了应用的好坏。

## buff

建模过程中最不容易拎明白的就是buff系统。每个入驻的人物会有一个buff，能对建筑内各项属性进行影响，比如影响角色的疲劳值消耗、影响物品的每小时产出分数、影响物品的库存总量等。

通过一种什么样的姿势，根据外界输入，改变属性的值

我改变的是Worker，但同时，房间内的其他属性也会随着改变

会想到钩子函数

但是，每个人物所携带的buff是不一样的，而且要方便配置，改变的属性的量是从repo中读取的。